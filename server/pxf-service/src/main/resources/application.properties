# Expose health, info, shutdown, metrics, and prometheus endpoints by default
# 1. health: returns the status of the application {"status":"UP"}
# 2. info: returns information about the build {"build":{"version":"X.X.X","artifact":"pxf-service","name":"pxf-service","group":"org.greenplum.pxf","time":"timestamp"}}
# 3. shutdown: allows shutting down the application
# 4. metrics: shows ‘metrics’ information for the application
# 5. prometheus: exposes metrics in a format that can be scraped by a Prometheus server
management.endpoints.web.exposure.include=health,info,shutdown,metrics,prometheus
management.endpoint.shutdown.enabled=true
management.endpoint.health.probes.enabled=true

# common tags applied to all metrics
management.metrics.tags.application=pxf-service

# PXF-specific metrics
pxf.metrics.fragments.enabled=true
pxf.metrics.records.enabled=true
pxf.metrics.bytes.enabled=true
pxf.metrics.report-frequency=1000

pxf.fragmenter-cache.expiration=10s
pxf.service.kerberos.constrained-delegation.credential-cache.expiration=1d

spring.profiles.active=default

# SSL configuration
# enable/disable SSL
server.ssl.enabled=${PXF_SSL_ENABLED:false}
# the list of supported TLS protocols (separated by comma)
server.ssl.enabled-protocols=${PXF_SSL_ENABLED_PROTOCOLS:TLSv1.2}
# path to the keystore with server private key and signed server certificate
server.ssl.key-store=${PXF_SSL_KEY_STORE_PATH:classpath:cert/server.p12}
# password to the keystore
server.ssl.key-store-password=${PXF_SSL_KEY_STORE_PASSWORD:}
# type of the keystore
server.ssl.key-store-type=${PXF_SSL_KEY_STORE_TYPE:PKCS12}
# client authentication method. NONE won't check certificate, NEED - for mTLS
server.ssl.client-auth=${PXF_SSL_CLIENT_AUTH:NONE}
# path to the truststore with client private key and signed client certificate
server.ssl.trust-store=${PXF_SSL_TRUST_STORE_PATH:classpath:cert/truststore.p12}
# password to the truststore
server.ssl.trust-store-password=${PXF_SSL_TRUST_STORE_PASSWORD:}
# type of the truststore
server.ssl.trust-store-type=${PXF_SSL_TRUST_STORE_TYPE:PKCS12}

# Vault integration
spring.cloud.vault.enabled=${PXF_VAULT_ENABLED:false}
spring.cloud.vault.kv.enabled=${PXF_VAULT_KV_ENABLED:true}
spring.cloud.vault.kv.backend=${PXF_VAULT_MOUNT_PATH:secret}
spring.cloud.vault.kv.application-name=${PXF_VAULT_SECRET_PATH:}
spring.cloud.vault.kv.default-context=${PXF_VAULT_DEFAULT_CONTEXT:}
spring.cloud.vault.kv.profiles=${PXF_VAULT_KV_PROFILES:}
spring.cloud.vault.fail-fast=${PXF_VAULT_FAIL_FAST:true}
spring.cloud.vault.namespace=${PXF_VAULT_NAMESPACE}
spring.cloud.vault.host=${PXF_VAULT_HOST:vault}
spring.cloud.vault.port=${PXF_VAULT_PORT:8200}
spring.cloud.vault.scheme=${PXF_VAULT_SCHEME_TYPE:https}
spring.cloud.vault.authentication=${PXF_VAULT_AUTHENTICATION_TYPE:approle}
spring.cloud.vault.app-role.role-id=${PXF_VAULT_ROLE_ID}
spring.cloud.vault.app-role.secret-id=${PXF_VAULT_SECRET_ID}
spring.cloud.vault.token=${PXF_VAULT_TOKEN}
spring.cloud.vault.ssl.trust-store=${PXF_VAULT_SSL_TRUST_STORE:file:/opt/ssl/certs/pxf.jks}
spring.cloud.vault.ssl.trust-store-password=${PXF_VAULT_SSL_TRUST_STORE_PASSWORD:123456}
spring.config.import=optional:${PXF_VAULT_CONFIG_IMPORT:vault://}

# server network interface and port to bind the listening socket to, use localhost by default for local traffic only
server.address=localhost
server.port=${pxf.port:5888}

# Whitelabel error options
server.error.include-message=always
server.error.include-stacktrace=on_param
server.error.include-exception=false

server.server-header=PXF Server
server.max-http-header-size=${pxf.tomcat.max-header-size:1048576}

# tomcat specific
server.tomcat.threads.max=${pxf.max.threads:200}
server.tomcat.accept-count=100
server.tomcat.connection-timeout=${pxf.connection.timeout:5m}
server.tomcat.mbeanregistry.enabled=true
pxf.tomcat.max-header-count=30000
pxf.tomcat.disable-upload-timeout=false
pxf.tomcat.connection-upload-timeout=${pxf.connection.upload-timeout:5m}

# timeout (ms) for the request - 1 day
# TODO: spring_boot_todo what value should we set here
spring.mvc.async.request-timeout=86400000

pxf.task.thread-name-prefix=pxf-response-
pxf.task.pool.allow-core-thread-timeout=false
pxf.task.pool.core-size=8
pxf.task.pool.max-size=${pxf.max.threads:200}
pxf.task.pool.queue-capacity=0

# PXF feature flags used to turn off new functionality, if required
pxf.features.kerberos.expand-user-principal=true

# logging
pxf.log.level=info
logging.file.name=${pxf.logdir:/tmp}/pxf-service.log
logging.file.path=${pxf.logdir:/tmp}

# Nested exception information logging
# If it is true, the pxf will return an extended error message to the Greenplum
pxf.nested-exception-enabled=false
# Set to 0, if you don't need wrapped stack traces
pxf.nested-exception-wrapped-depth=1000
# Set to 0, if you don't need stack trace for the last exception
pxf.nested-exception-trace-depth=10

# regex for profile names that makes profiles dynamic, i.e. allows for the profile names to be
# missing from the profile configuration file and have user specify Fragmenter / Accessor / Resolver directly
# as query options. The default value is empty.
# Used by FDW test cases that setup this property for test:* profiles and custom test Fragmenters / Accessors / Resolvers
pxf.profile.dynamic.regex=

cluster-name=${cluster_name:}

# eureka
eureka.client.enabled=${adcc_enabled:false}
eureka.client.service-url.defaultZone=${ADCC_EUREKA_CLIENT_SERV_URL_DEF_ZONE:http://0.0.0.0:8761/eureka}
eureka.instance.prefer-ip-address=${ADCC_EUREKA_CLIENT_PREFER_IP_ADDRESS:true}
eureka.instance.hostname=${pxf_hostname:localhost}
eureka.instance.ip-address=${pxf_ip_address:127.0.0.1}
eureka.instance.appname=PXF SERVICE
eureka.instance.metadata-map.port=${server.port}
eureka.instance.metadata-map.cluster=${cluster-name}
eureka.instance.metadata-map.name=pxf-service
eureka.instance.metadata-map.version=${pxf-version:0.0.0-SNAPSHOT}
eureka.instance.metadata-map.status=UP